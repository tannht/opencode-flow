{"version":3,"sources":["../../../src/mcp/server-mcp-2025.ts"],"sourcesContent":["/**\n * MCP 2025-11 Enhanced Server\n *\n * Integrates all MCP 2025-11 features with full backward compatibility:\n * - Version negotiation\n * - Async job support\n * - Registry integration\n * - JSON Schema 1.1 validation\n * - Dual-mode operation (2025-11 + legacy)\n */\n\nimport type { ILogger } from '../interfaces/logger.js';\nimport type { IEventBus } from '../interfaces/event-bus.js';\nimport { VersionNegotiator, BackwardCompatibilityAdapter, type MCPHandshake, type MCPVersion, type MCPCapability } from './protocol/version-negotiation.js';\nimport { MCPAsyncJobManager, type MCPToolRequest, type MCPJobHandle, type MCPJobResult } from './async/job-manager-mcp25.js';\nimport { MCPRegistryClient, type RegistryConfig } from './registry/mcp-registry-client-2025.js';\nimport { SchemaValidator, upgradeToolSchema } from './validation/schema-validator-2025.js';\nimport { ProgressiveToolRegistry } from './tool-registry-progressive.js';\n\n/**\n * MCP 2025-11 server configuration\n */\nexport interface MCP2025ServerConfig {\n  serverId: string;\n  transport: 'stdio' | 'http' | 'ws';\n\n  // Version & capabilities\n  enableMCP2025: boolean; // Feature flag for gradual rollout\n  supportLegacyClients: boolean; // Backward compatibility\n\n  // Async jobs\n  async: {\n    enabled: boolean;\n    maxJobs?: number;\n    jobTTL?: number;\n    persistence?: 'memory' | 'redis' | 'sqlite';\n  };\n\n  // Registry\n  registry: RegistryConfig;\n\n  // Schema validation\n  validation: {\n    enabled: boolean;\n    strictMode?: boolean;\n  };\n\n  // Tool registry\n  toolsDirectory?: string;\n\n  // Existing config\n  orchestratorContext?: any;\n}\n\n/**\n * MCP 2025-11 Enhanced Server\n */\nexport class MCP2025Server {\n  private versionNegotiator: VersionNegotiator;\n  private compatibilityAdapter: BackwardCompatibilityAdapter;\n  private jobManager?: MCPAsyncJobManager;\n  private registryClient?: MCPRegistryClient;\n  private schemaValidator: SchemaValidator;\n  private toolRegistry: ProgressiveToolRegistry;\n\n  // Session state\n  private sessions: Map<string, {\n    clientId: string;\n    version: MCPVersion;\n    capabilities: MCPCapability[];\n    isLegacy: boolean;\n    createdAt: number;\n    lastAccess: number;\n  }> = new Map();\n\n  // Session management constants\n  private readonly MAX_SESSIONS = 10000;\n  private readonly SESSION_TTL = 3600000; // 1 hour\n  private sessionCleanupInterval?: NodeJS.Timeout;\n\n  constructor(\n    private config: MCP2025ServerConfig,\n    private eventBus: IEventBus,\n    private logger: ILogger\n  ) {\n    // Initialize version negotiation\n    this.versionNegotiator = new VersionNegotiator(logger);\n    this.compatibilityAdapter = new BackwardCompatibilityAdapter(logger);\n\n    // Initialize schema validator\n    this.schemaValidator = new SchemaValidator(logger);\n\n    // Initialize tool registry (progressive)\n    this.toolRegistry = new ProgressiveToolRegistry({\n      enableInProcess: true,\n      enableMetrics: true,\n      enableCaching: true,\n      orchestratorContext: config.orchestratorContext,\n      toolsDirectory: config.toolsDirectory,\n    });\n\n    this.logger.info('MCP 2025-11 server created', {\n      serverId: config.serverId,\n      mcp2025Enabled: config.enableMCP2025,\n      legacySupport: config.supportLegacyClients,\n    });\n  }\n\n  /**\n   * Initialize server\n   */\n  async initialize(): Promise<void> {\n    this.logger.info('Initializing MCP 2025-11 server');\n\n    // Initialize tool registry\n    await this.toolRegistry.initialize();\n\n    // Start session cleanup interval\n    this.sessionCleanupInterval = setInterval(\n      () => this.cleanupExpiredSessions(),\n      300000 // Every 5 minutes\n    );\n\n    // Initialize async job manager if enabled\n    if (this.config.async.enabled) {\n      this.jobManager = new MCPAsyncJobManager(\n        null, // Use memory persistence for now\n        this.logger,\n        {\n          maxJobs: this.config.async.maxJobs,\n          jobTTL: this.config.async.jobTTL,\n        }\n      );\n\n      this.logger.info('Async job manager initialized');\n    }\n\n    // Initialize registry client if enabled\n    if (this.config.registry.enabled) {\n      this.registryClient = new MCPRegistryClient(\n        this.config.registry,\n        this.logger,\n        () => this.toolRegistry.getToolNames(),\n        () => this.versionNegotiator.getServerCapabilities(),\n        async () => this.getHealthStatus()\n      );\n\n      // Register with MCP Registry\n      try {\n        await this.registryClient.register();\n      } catch (error) {\n        this.logger.error('Failed to register with MCP Registry', { error });\n        // Don't fail initialization if registry is unavailable\n      }\n    }\n\n    this.logger.info('MCP 2025-11 server initialized successfully');\n  }\n\n  /**\n   * Handle client connection/handshake\n   */\n  async handleHandshake(clientHandshake: any, sessionId: string): Promise<MCPHandshake> {\n    // Check if legacy client\n    const isLegacy = this.compatibilityAdapter.isLegacyRequest(clientHandshake);\n\n    let handshake: MCPHandshake;\n    if (isLegacy && this.config.supportLegacyClients) {\n      this.logger.info('Legacy client detected, enabling compatibility mode', { sessionId });\n      handshake = this.compatibilityAdapter.convertToModern(clientHandshake);\n    } else {\n      handshake = clientHandshake;\n    }\n\n    // Negotiate version and capabilities\n    const negotiation = await this.versionNegotiator.negotiate(handshake);\n\n    if (!negotiation.success) {\n      throw new Error(`Version negotiation failed: ${negotiation.error}`);\n    }\n\n    // Enforce session limit\n    if (this.sessions.size >= this.MAX_SESSIONS) {\n      // Remove oldest session\n      const oldestSession = Array.from(this.sessions.entries())\n        .sort((a, b) => a[1].createdAt - b[1].createdAt)[0];\n      if (oldestSession) {\n        this.sessions.delete(oldestSession[0]);\n        this.logger.warn('Session limit reached, removed oldest session', {\n          removedSessionId: oldestSession[0],\n        });\n      }\n    }\n\n    // Store session info\n    const now = Date.now();\n    this.sessions.set(sessionId, {\n      clientId: handshake.client_id || 'unknown',\n      version: negotiation.agreed_version,\n      capabilities: negotiation.agreed_capabilities,\n      isLegacy,\n      createdAt: now,\n      lastAccess: now,\n    });\n\n    // Create server handshake response\n    const serverHandshake = this.versionNegotiator.createServerHandshake(\n      this.config.serverId,\n      this.config.transport,\n      {\n        name: 'Claude Flow',\n        version: '2.7.32',\n        description: 'Enterprise AI orchestration with MCP 2025-11 support',\n      }\n    );\n\n    // Apply agreed version and capabilities\n    serverHandshake.mcp_version = negotiation.agreed_version;\n    serverHandshake.capabilities = negotiation.agreed_capabilities;\n\n    this.logger.info('Handshake completed', {\n      sessionId,\n      version: serverHandshake.mcp_version,\n      capabilities: serverHandshake.capabilities,\n      isLegacy,\n    });\n\n    return serverHandshake;\n  }\n\n  /**\n   * Handle tool call request (with async support)\n   */\n  async handleToolCall(\n    request: MCPToolRequest | any,\n    sessionId: string\n  ): Promise<MCPJobHandle | MCPJobResult | any> {\n    const session = this.sessions.get(sessionId);\n\n    // Update last access time\n    if (session) {\n      session.lastAccess = Date.now();\n    }\n\n    // Handle legacy request format\n    if (session?.isLegacy) {\n      return this.handleLegacyToolCall(request, sessionId);\n    }\n\n    // MCP 2025-11 format\n    const mcpRequest = request as MCPToolRequest;\n\n    // Validate request\n    if (!mcpRequest.tool_id) {\n      throw new Error('Missing tool_id in request');\n    }\n\n    // Get tool\n    const tool = await this.toolRegistry.getTool(mcpRequest.tool_id);\n    if (!tool) {\n      throw new Error(`Tool not found: ${mcpRequest.tool_id}`);\n    }\n\n    // Validate input if validation enabled\n    if (this.config.validation.enabled) {\n      const validation = this.schemaValidator.validateInput(\n        upgradeToolSchema(tool.inputSchema),\n        mcpRequest.arguments\n      );\n\n      if (!validation.valid) {\n        throw new Error(\n          `Invalid input: ${validation.errors?.map(e => e.message).join(', ')}`\n        );\n      }\n    }\n\n    // Check if async mode requested\n    const hasAsyncCapability = session?.capabilities.includes('async');\n    const isAsyncRequest = mcpRequest.mode === 'async' && hasAsyncCapability;\n\n    if (isAsyncRequest && this.jobManager) {\n      // Submit as async job\n      this.logger.info('Submitting async job', {\n        tool_id: mcpRequest.tool_id,\n        request_id: mcpRequest.request_id,\n      });\n\n      return await this.jobManager.submitJob(\n        mcpRequest,\n        async (args, onProgress) => {\n          // Execute tool with progress tracking\n          return await tool.handler(args, {\n            orchestrator: this.config.orchestratorContext,\n            sessionId,\n          });\n        }\n      );\n    } else {\n      // Execute synchronously\n      this.logger.info('Executing tool synchronously', {\n        tool_id: mcpRequest.tool_id,\n        request_id: mcpRequest.request_id,\n      });\n\n      const startTime = Date.now();\n      const result = await tool.handler(mcpRequest.arguments, {\n        orchestrator: this.config.orchestratorContext,\n        sessionId,\n      });\n\n      // Validate output if validation enabled\n      if (this.config.validation.enabled && tool.metadata?.outputSchema) {\n        const validation = this.schemaValidator.validateOutput(\n          tool.metadata.outputSchema,\n          result\n        );\n\n        if (!validation.valid) {\n          this.logger.warn('Output validation failed', {\n            tool_id: mcpRequest.tool_id,\n            errors: validation.errors,\n          });\n        }\n      }\n\n      // Return in MCP 2025-11 format\n      return {\n        request_id: mcpRequest.request_id,\n        status: 'success',\n        result,\n        metadata: {\n          duration_ms: Date.now() - startTime,\n        },\n      } as MCPJobResult;\n    }\n  }\n\n  /**\n   * Handle legacy tool call\n   */\n  private async handleLegacyToolCall(request: any, sessionId: string): Promise<any> {\n    this.logger.info('Handling legacy tool call', {\n      toolName: request.name || request.method,\n      sessionId,\n    });\n\n    // Convert to modern format internally\n    const toolId = request.name || request.method;\n    const args = request.arguments || request.params || {};\n\n    const tool = await this.toolRegistry.getTool(toolId);\n    if (!tool) {\n      throw new Error(`Tool not found: ${toolId}`);\n    }\n\n    const result = await tool.handler(args, {\n      orchestrator: this.config.orchestratorContext,\n      sessionId,\n    });\n\n    // Return in legacy format\n    return this.compatibilityAdapter.convertToLegacy(\n      { result, status: 'success' },\n      true\n    );\n  }\n\n  /**\n   * Poll async job\n   */\n  async pollJob(job_id: string): Promise<MCPJobHandle> {\n    if (!this.jobManager) {\n      throw new Error('Async jobs not enabled');\n    }\n\n    return await this.jobManager.pollJob(job_id);\n  }\n\n  /**\n   * Resume async job (get results)\n   */\n  async resumeJob(job_id: string): Promise<MCPJobResult> {\n    if (!this.jobManager) {\n      throw new Error('Async jobs not enabled');\n    }\n\n    return await this.jobManager.resumeJob(job_id);\n  }\n\n  /**\n   * Cancel async job\n   */\n  async cancelJob(job_id: string): Promise<boolean> {\n    if (!this.jobManager) {\n      throw new Error('Async jobs not enabled');\n    }\n\n    return await this.jobManager.cancelJob(job_id);\n  }\n\n  /**\n   * List async jobs\n   */\n  async listJobs(filter?: { status?: string; limit?: number }) {\n    if (!this.jobManager) {\n      throw new Error('Async jobs not enabled');\n    }\n\n    return await this.jobManager.listJobs(filter);\n  }\n\n  /**\n   * Get health status\n   */\n  private async getHealthStatus(): Promise<{\n    status: 'healthy' | 'degraded' | 'unhealthy';\n    latency_ms: number;\n  }> {\n    const startTime = Date.now();\n\n    // Perform health checks\n    const latency = Date.now() - startTime;\n\n    // Determine status based on metrics\n    let status: 'healthy' | 'degraded' | 'unhealthy' = 'healthy';\n\n    if (latency > 100) {\n      status = 'degraded';\n    }\n    if (latency > 500) {\n      status = 'unhealthy';\n    }\n\n    return { status, latency_ms: latency };\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics() {\n    return {\n      sessions: {\n        total: this.sessions.size,\n        byVersion: this.getSessionsByVersion(),\n        legacy: Array.from(this.sessions.values()).filter(s => s.isLegacy).length,\n      },\n      jobs: this.jobManager?.getMetrics(),\n      tools: this.toolRegistry.getMetrics(),\n      validation: this.schemaValidator.getCacheStats(),\n    };\n  }\n\n  private getSessionsByVersion() {\n    const counts: Record<string, number> = {};\n    for (const session of this.sessions.values()) {\n      counts[session.version] = (counts[session.version] || 0) + 1;\n    }\n    return counts;\n  }\n\n  /**\n   * Cleanup expired sessions\n   */\n  private cleanupExpiredSessions(): void {\n    const now = Date.now();\n    let cleaned = 0;\n\n    for (const [sessionId, session] of this.sessions.entries()) {\n      // Remove if last access was more than TTL ago\n      if (now - session.lastAccess > this.SESSION_TTL) {\n        this.sessions.delete(sessionId);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      this.logger.info('Cleaned up expired sessions', { count: cleaned });\n    }\n  }\n\n  /**\n   * Cleanup resources\n   */\n  async cleanup(): Promise<void> {\n    this.logger.info('Cleaning up MCP 2025-11 server');\n\n    // Stop session cleanup interval\n    if (this.sessionCleanupInterval) {\n      clearInterval(this.sessionCleanupInterval);\n    }\n\n    // Unregister from registry\n    if (this.registryClient) {\n      await this.registryClient.unregister();\n    }\n\n    // Clear caches\n    this.schemaValidator.clearCache();\n    await this.toolRegistry.cleanup();\n\n    // Clear sessions\n    this.sessions.clear();\n\n    this.logger.info('Cleanup complete');\n  }\n}\n"],"names":["VersionNegotiator","BackwardCompatibilityAdapter","MCPAsyncJobManager","MCPRegistryClient","SchemaValidator","upgradeToolSchema","ProgressiveToolRegistry","MCP2025Server","versionNegotiator","compatibilityAdapter","jobManager","registryClient","schemaValidator","toolRegistry","sessions","Map","MAX_SESSIONS","SESSION_TTL","sessionCleanupInterval","config","eventBus","logger","enableInProcess","enableMetrics","enableCaching","orchestratorContext","toolsDirectory","info","serverId","mcp2025Enabled","enableMCP2025","legacySupport","supportLegacyClients","initialize","setInterval","cleanupExpiredSessions","async","enabled","maxJobs","jobTTL","registry","getToolNames","getServerCapabilities","getHealthStatus","register","error","handleHandshake","clientHandshake","sessionId","isLegacy","isLegacyRequest","handshake","convertToModern","negotiation","negotiate","success","Error","size","oldestSession","Array","from","entries","sort","a","b","createdAt","delete","warn","removedSessionId","now","Date","set","clientId","client_id","version","agreed_version","capabilities","agreed_capabilities","lastAccess","serverHandshake","createServerHandshake","transport","name","description","mcp_version","handleToolCall","request","session","get","handleLegacyToolCall","mcpRequest","tool_id","tool","getTool","validation","validateInput","inputSchema","arguments","valid","errors","map","e","message","join","hasAsyncCapability","includes","isAsyncRequest","mode","request_id","submitJob","args","onProgress","handler","orchestrator","startTime","result","metadata","outputSchema","validateOutput","status","duration_ms","toolName","method","toolId","params","convertToLegacy","pollJob","job_id","resumeJob","cancelJob","listJobs","filter","latency","latency_ms","getMetrics","total","byVersion","getSessionsByVersion","legacy","values","s","length","jobs","tools","getCacheStats","counts","cleaned","count","cleanup","clearInterval","unregister","clearCache","clear"],"mappings":"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"}