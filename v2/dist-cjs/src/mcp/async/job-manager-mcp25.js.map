{"version":3,"sources":["../../../../src/mcp/async/job-manager-mcp25.ts"],"sourcesContent":["/**\n * MCP 2025-11 Async Job Manager\n *\n * Implements async job lifecycle per MCP 2025-11 specification:\n * - Job handles with request_id\n * - Poll/resume semantics\n * - Progress tracking\n * - Job persistence\n */\n\nimport { EventEmitter } from 'events';\nimport { v4 as uuidv4 } from 'uuid';\nimport type { ILogger } from '../../interfaces/logger.js';\n\n/**\n * MCP tool request (2025-11 format)\n */\nexport interface MCPToolRequest {\n  request_id: string;\n  tool_id: string;\n  arguments: Record<string, any>;\n  session?: string;\n  mode: 'async' | 'sync';\n  context?: {\n    trace_id?: string;\n    client_name?: string;\n    [key: string]: any;\n  };\n}\n\n/**\n * MCP job handle (2025-11 format)\n */\nexport interface MCPJobHandle {\n  request_id: string;\n  job_id: string;\n  status: 'in_progress' | 'success' | 'error';\n  poll_after: number; // seconds\n  progress?: {\n    percent: number;\n    message?: string;\n  };\n}\n\n/**\n * MCP job result (2025-11 format)\n */\nexport interface MCPJobResult {\n  request_id: string;\n  status: 'success' | 'error' | 'in_progress';\n  result?: any;\n  error?: {\n    code: string;\n    message: string;\n    details?: any;\n  };\n  progress?: {\n    percent: number;\n    message?: string;\n  };\n  metadata: {\n    duration_ms?: number;\n    tokens_used?: number;\n    [key: string]: any;\n  };\n}\n\n/**\n * Internal job state\n */\ninterface AsyncJob {\n  request_id: string;\n  job_id: string;\n  tool_id: string;\n  arguments: Record<string, any>;\n  mode: 'async' | 'sync';\n  status: 'queued' | 'running' | 'success' | 'error' | 'cancelled';\n  progress: number;\n  progress_message?: string;\n  result?: any;\n  error?: any;\n  context?: any;\n  created_at: Date;\n  started_at?: Date;\n  completed_at?: Date;\n  tokens_used?: number;\n  abortController?: AbortController;\n}\n\n/**\n * Job persistence interface\n */\nexport interface JobPersistence {\n  save(job: AsyncJob): Promise<void>;\n  load(job_id: string): Promise<AsyncJob | null>;\n  list(filter?: { status?: string; limit?: number }): Promise<AsyncJob[]>;\n  delete(job_id: string): Promise<void>;\n}\n\n/**\n * Simple in-memory job persistence (fallback)\n */\nexport class MemoryJobPersistence implements JobPersistence {\n  private jobs: Map<string, AsyncJob> = new Map();\n\n  async save(job: AsyncJob): Promise<void> {\n    this.jobs.set(job.job_id, { ...job });\n  }\n\n  async load(job_id: string): Promise<AsyncJob | null> {\n    const job = this.jobs.get(job_id);\n    return job ? { ...job } : null;\n  }\n\n  async list(filter?: { status?: string; limit?: number }): Promise<AsyncJob[]> {\n    let jobs = Array.from(this.jobs.values());\n\n    if (filter?.status) {\n      jobs = jobs.filter(j => j.status === filter.status);\n    }\n\n    if (filter?.limit) {\n      jobs = jobs.slice(0, filter.limit);\n    }\n\n    return jobs;\n  }\n\n  async delete(job_id: string): Promise<void> {\n    this.jobs.delete(job_id);\n  }\n}\n\n/**\n * MCP 2025-11 Async Job Manager\n */\nexport class MCPAsyncJobManager extends EventEmitter {\n  private jobs: Map<string, AsyncJob> = new Map();\n  private executors: Map<string, Promise<any>> = new Map();\n  private persistence: JobPersistence;\n\n  constructor(\n    persistence: JobPersistence | null,\n    private logger: ILogger,\n    private config: {\n      maxJobs?: number;\n      jobTTL?: number;\n      defaultPollInterval?: number;\n    } = {}\n  ) {\n    super();\n    this.persistence = persistence || new MemoryJobPersistence();\n\n    // Default config\n    this.config.maxJobs = this.config.maxJobs || 1000;\n    this.config.jobTTL = this.config.jobTTL || 86400000; // 24 hours\n    this.config.defaultPollInterval = this.config.defaultPollInterval || 5;\n\n    // Cleanup expired jobs periodically\n    setInterval(() => this.cleanupExpiredJobs(), 3600000); // Every hour\n  }\n\n  /**\n   * Submit async job (MCP 2025-11 format)\n   */\n  async submitJob(\n    request: MCPToolRequest,\n    executor: (args: any, onProgress: (percent: number, message?: string) => void) => Promise<any>\n  ): Promise<MCPJobHandle> {\n    // Check capacity\n    if (this.jobs.size >= this.config.maxJobs!) {\n      throw new Error('Job queue full. Please try again later.');\n    }\n\n    // Check for duplicate request_id (prevent race conditions)\n    const existingJob = Array.from(this.jobs.values()).find(\n      j => j.request_id === request.request_id &&\n           (j.status === 'queued' || j.status === 'running')\n    );\n    if (existingJob) {\n      throw new Error(`Duplicate request_id: ${request.request_id}. Job already submitted.`);\n    }\n\n    // Create job\n    const job: AsyncJob = {\n      request_id: request.request_id,\n      job_id: uuidv4(),\n      tool_id: request.tool_id,\n      arguments: request.arguments,\n      mode: request.mode,\n      status: 'queued',\n      progress: 0,\n      context: request.context,\n      created_at: new Date(),\n    };\n\n    // Save to persistence\n    await this.persistence.save(job);\n    this.jobs.set(job.job_id, job);\n\n    this.logger.info('Job submitted', {\n      job_id: job.job_id,\n      request_id: job.request_id,\n      tool_id: job.tool_id,\n    });\n\n    // Start execution in background\n    this.executeJob(job, executor);\n\n    // Return job handle immediately\n    return {\n      request_id: job.request_id,\n      job_id: job.job_id,\n      status: 'in_progress',\n      poll_after: this.config.defaultPollInterval!,\n    };\n  }\n\n  /**\n   * Poll job status\n   */\n  async pollJob(job_id: string): Promise<MCPJobHandle> {\n    const job = await this.persistence.load(job_id);\n\n    if (!job) {\n      throw new Error(`Job not found: ${job_id}`);\n    }\n\n    const status = job.status === 'success' ? 'success' :\n                   job.status === 'error' ? 'error' : 'in_progress';\n\n    const handle: MCPJobHandle = {\n      request_id: job.request_id,\n      job_id: job.job_id,\n      status,\n      poll_after: status === 'in_progress' ? this.config.defaultPollInterval! : 0,\n    };\n\n    if (status === 'in_progress') {\n      handle.progress = {\n        percent: job.progress,\n        message: job.progress_message,\n      };\n    }\n\n    return handle;\n  }\n\n  /**\n   * Resume job (get results)\n   */\n  async resumeJob(job_id: string): Promise<MCPJobResult> {\n    const job = await this.persistence.load(job_id);\n\n    if (!job) {\n      throw new Error(`Job not found: ${job_id}`);\n    }\n\n    const result: MCPJobResult = {\n      request_id: job.request_id,\n      status: job.status === 'success' ? 'success' :\n              job.status === 'error' ? 'error' : 'in_progress',\n      metadata: {},\n    };\n\n    if (job.status === 'success') {\n      result.result = job.result;\n      result.metadata.duration_ms = job.completed_at && job.started_at\n        ? job.completed_at.getTime() - job.started_at.getTime()\n        : undefined;\n      result.metadata.tokens_used = job.tokens_used;\n    } else if (job.status === 'error') {\n      result.error = {\n        code: 'EXECUTION_ERROR',\n        message: job.error?.message || 'Job execution failed',\n        details: job.error,\n      };\n    } else {\n      // Still in progress\n      result.progress = {\n        percent: job.progress,\n        message: job.progress_message,\n      };\n    }\n\n    return result;\n  }\n\n  /**\n   * Cancel a running job\n   */\n  async cancelJob(job_id: string): Promise<boolean> {\n    const job = this.jobs.get(job_id);\n\n    if (!job) {\n      return false;\n    }\n\n    if (job.status === 'success' || job.status === 'error') {\n      return false; // Already finished\n    }\n\n    // Abort execution if AbortController is available\n    if (job.abortController) {\n      job.abortController.abort();\n    }\n\n    job.status = 'cancelled';\n    job.completed_at = new Date();\n    await this.persistence.save(job);\n\n    this.emit('job:cancelled', job_id);\n    this.logger.info('Job cancelled', { job_id });\n\n    return true;\n  }\n\n  /**\n   * List jobs\n   */\n  async listJobs(filter?: {\n    status?: string;\n    limit?: number;\n  }): Promise<AsyncJob[]> {\n    return await this.persistence.list(filter);\n  }\n\n  /**\n   * Execute job in background\n   */\n  private async executeJob(\n    job: AsyncJob,\n    executor: (args: any, onProgress: (percent: number, message?: string) => void) => Promise<any>\n  ): Promise<void> {\n    // Update status to running\n    job.status = 'running';\n    job.started_at = new Date();\n\n    // Create AbortController for cancellation support\n    job.abortController = new AbortController();\n\n    await this.persistence.save(job);\n\n    this.emit('job:started', job.job_id);\n    this.logger.info('Job started', { job_id: job.job_id, tool_id: job.tool_id });\n\n    try {\n      // Progress callback\n      const onProgress = (percent: number, message?: string) => {\n        job.progress = Math.min(100, Math.max(0, percent));\n        job.progress_message = message;\n        this.persistence.save(job).catch(err =>\n          this.logger.error('Failed to save progress', { job_id: job.job_id, error: err })\n        );\n        this.emit('job:progress', job.job_id, job.progress, message);\n      };\n\n      // Check if already cancelled\n      if (job.abortController.signal.aborted) {\n        throw new Error('Job cancelled before execution');\n      }\n\n      // Execute with abort support\n      const result = await executor(job.arguments, onProgress);\n\n      // Mark successful\n      job.status = 'success';\n      job.result = result;\n      job.progress = 100;\n      job.completed_at = new Date();\n      await this.persistence.save(job);\n\n      this.emit('job:completed', job.job_id, result);\n      this.logger.info('Job completed', {\n        job_id: job.job_id,\n        duration_ms: job.completed_at.getTime() - job.started_at!.getTime(),\n      });\n    } catch (error: any) {\n      // Mark failed\n      job.status = 'error';\n      job.error = {\n        message: error.message,\n        stack: error.stack,\n        code: error.code,\n      };\n      job.completed_at = new Date();\n      await this.persistence.save(job);\n\n      this.emit('job:failed', job.job_id, error);\n      this.logger.error('Job failed', {\n        job_id: job.job_id,\n        error: error.message,\n      });\n    }\n  }\n\n  /**\n   * Cleanup expired jobs\n   */\n  private async cleanupExpiredJobs(): Promise<number> {\n    const now = Date.now();\n    const jobs = await this.persistence.list();\n    let cleaned = 0;\n\n    for (const job of jobs) {\n      const age = now - job.created_at.getTime();\n\n      // Remove if expired and not running\n      if (age > this.config.jobTTL! && job.status !== 'running') {\n        await this.persistence.delete(job.job_id);\n        this.jobs.delete(job.job_id);\n        cleaned++;\n      }\n    }\n\n    if (cleaned > 0) {\n      this.logger.info('Cleaned up expired jobs', { count: cleaned });\n    }\n\n    return cleaned;\n  }\n\n  /**\n   * Get metrics\n   */\n  getMetrics() {\n    const jobs = Array.from(this.jobs.values());\n\n    return {\n      total: jobs.length,\n      byStatus: {\n        queued: jobs.filter(j => j.status === 'queued').length,\n        running: jobs.filter(j => j.status === 'running').length,\n        success: jobs.filter(j => j.status === 'success').length,\n        error: jobs.filter(j => j.status === 'error').length,\n        cancelled: jobs.filter(j => j.status === 'cancelled').length,\n      },\n      averageDuration: this.calculateAverageDuration(jobs),\n    };\n  }\n\n  private calculateAverageDuration(jobs: AsyncJob[]): number {\n    const completed = jobs.filter(j =>\n      (j.status === 'success' || j.status === 'error') &&\n      j.started_at && j.completed_at\n    );\n\n    if (completed.length === 0) return 0;\n\n    const total = completed.reduce((sum, j) =>\n      sum + (j.completed_at!.getTime() - j.started_at!.getTime()), 0\n    );\n\n    return total / completed.length;\n  }\n}\n"],"names":["EventEmitter","v4","uuidv4","MemoryJobPersistence","jobs","Map","save","job","set","job_id","load","get","list","filter","Array","from","values","status","j","limit","slice","delete","MCPAsyncJobManager","executors","persistence","logger","config","maxJobs","jobTTL","defaultPollInterval","setInterval","cleanupExpiredJobs","submitJob","request","executor","size","Error","existingJob","find","request_id","tool_id","arguments","mode","progress","context","created_at","Date","info","executeJob","poll_after","pollJob","handle","percent","message","progress_message","resumeJob","result","metadata","duration_ms","completed_at","started_at","getTime","undefined","tokens_used","error","code","details","cancelJob","abortController","abort","emit","listJobs","AbortController","onProgress","Math","min","max","catch","err","signal","aborted","stack","now","cleaned","age","count","getMetrics","total","length","byStatus","queued","running","success","cancelled","averageDuration","calculateAverageDuration","completed","reduce","sum"],"mappings":"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"}